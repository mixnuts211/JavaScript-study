## 생성자 함수에 의한 객체 생성

### 생성자 함수가 뭔가요?

생성자 함수란 new 연산자와 함께 호출하여 객체(<u>인스턴스</u>)를 생성하는 함수를 말합니다.

new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있습니다.

```js
const makeObject = new Object();
// - 빈 객체 생성

// 프로퍼티 추가하기
makeObject.text = "put some property";

console.log(makeObject);
// 결과 값 : {text : "put some property"}
```

### 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?

생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 <strong>프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</strong>

### 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

      인스턴스
      객체 지향 프로그래밍에서 인스턴스는 해당 클래스의 구조로 컴퓨터 저장공간에서 할당된 실체를 의미한다. 여기서 클래스는 속성과 행위로 구성된 일종의 설계도 - 위키백과

1. 인스턴스 생성과 this 바인딩<br>
   암묵적으로 빈 객체 생성 ⇒ 생성자 함수가 생성한 인스턴스입니다. 이 인스턴스는 this에 바인딩됩니다. (런타임 이전)
2. 인스턴스 초기화<br>
   코드가 실행되면서 this에 바인딩 된 인스턴스에 프로퍼티나 메서드를 추가하고 인수로 전달 받는 초기값을 인스턴스 프로퍼티에 할당한다.
3. 인스턴스 반환<br>
   모든 처리가 끝나면 바인딩된 this가 암묵적으로 반환된다.

## 클로져

### 클로저에 대해서 아나요?

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합입니다

자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 **어디에 정의했는지에 따라 상위 스코프를 결정** 합니다. 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지 않습니다. 이는 **정적으로 결정되고 변하지 않습니다.**

```
함수의 상위 스코프를 결정한다. = 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다.
```

### 클로저를 사용하면 뭐가 좋죠?

클로저는 **상태를 안전하게 변경하고 유지하기 위해 사용** 합니다. 즉 상태가 의도치 않게 변경되지 않도록 **상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용** 하기 위해 사용됩니다.

캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말합니다.
캡슐화는 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 합니다.

- 정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호합니다.
- 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있습니다.

### 클로저를 어떻게 생성하나요?

- 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용될 때
- 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
- 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때
